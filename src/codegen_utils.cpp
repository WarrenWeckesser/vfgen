//
//  codegen_utils.cpp
//
//
//  Copyright (C) 2008 Warren Weckesser
//
//  This program is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License, Version 2, as
//  published by the Free Software Foundation.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License along
//  with this program.  The file LICENSE-GPL2 in the VFGEN source directory
//  contains a copy. You may also obtain a copy by writing to the Free Software
//  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
//


#include <fstream>
#include <iostream>
#include <sstream>
#include <string>
#include <ctime>
#include <ginac/ginac.h>

using namespace std;
using namespace GiNaC;

static const char *datetimefmt = "Generated on %2d-%3s-%04d at %02d:%02d";
static char datetimebuf[40]; // Must be enough space to hold a copy of datetimefmt

char *DateTimeMsg()
{
    time_t now_t;
    tm     now;
    const char *months[] = {"Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"};

    time(&now_t);
    now = *(localtime(&now_t));
    sprintf(datetimebuf,datetimefmt,
                  now.tm_mday,months[now.tm_mon],now.tm_year+1900,
                  now.tm_hour,now.tm_min);
    return(datetimebuf);
}


void PrintVFGENComment(ofstream &fout, const char *prefix)
{
    fout << prefix << "This file was generated by the program VFGEN (Version:" << VERSION << ")" << endl;
    fout << prefix << DateTimeMsg() << endl;
}

void Declare(ofstream &fout, string prefixstr, string typestr, lst names, string termstr)
{
    int n;

    n = names.nops();
    if (n < 1) {
        return;
    }
    fout << prefixstr << typestr << " ";
    for (int i = 0; i < n; ++i) {
        if (i > 0) {
            fout << ", ";
        }
        fout << names[i];
    }
    fout << termstr << endl;
}

void CDeclare(ofstream &fout, string typestr, lst names)
{
    int n;

    n = names.nops();
    if (n < 1) {
        return;
    }
    fout << "    " << typestr << " ";
    for (int i = 0; i < n; ++i) {
        if (i > 0) {
            fout << ", ";
        }
        fout << names[i];
    }
    fout << ";" << endl;
}


void CDeclare_double(ofstream &fout, lst names)
{
    int n;

    n = names.nops();
    if (n < 1) {
        return;
    }
    fout << "    double ";
    for (int i = 0; i < n; ++i) {
        if (i > 0) {
            fout << ", ";
        }
        fout << names[i];
    }
    fout << ";" << endl;
}


void MakeCArrayOfStrings(ofstream &fout, const char *var, lst names)
{
    int n;

    n = names.nops();
    if (n < 1) {
        return;
    }
    fout << "    char *" << var << "[" << n << "] = {" ;
    for (int i = 0; i < n; ++i) {
        if (i > 0) {
            fout << ", ";
        }
        fout << "\"" << names[i] << "\"";
    }
    fout << "};" << endl;
}

void MakePythonListOfStrings(ofstream &fout, const char *var, lst names, const char *pre)
{
    int n;

    n = names.nops();
    if (n < 1) {
        return;
    }
    fout << pre << var << " = [" ;
    for (int i = 0; i < n; ++i) {
        if (i > 0) {
            fout << ", ";
        }
        fout << "\"" << names[i] << "\"";
    }
    fout << "]" << endl;
}


void GetFromVector(ofstream &fout, const char *skip, lst names,
                   const char *assignop,
                   const char *vector,
                   const char *braces, int istart, const char *term)
{
    int n;

    n = names.nops();
    for (int i = 0; i < n; ++i) {
        fout << skip;
        fout.width(10);
        fout << left << names[i];
        fout.width(0);
        fout << " " << assignop << " " << vector << braces[0] << (i+istart) << braces[1] << term << endl;
    }
}


void GetFromVector2(ofstream &fout, const char *skip, lst names,
                    const char *assignop,
                    const char *vector,
                    const char *bropen, const char *brclose, int istart, const char *term)
{
    int n;

    n = names.nops();
    for (int i = 0; i < n; ++i) {
        fout << skip;
        fout.width(10);
        fout << left << names[i];
        fout.width(0);
        fout << " " << assignop << " " << vector << bropen << (i+istart) << brclose << term << endl;
    }
}


void SetVectorFromNames(ofstream &fout, const char *skip, const char *vector, lst names,
                      const char *braces, int istart, const char *term)
{
    int n;

    n = names.nops();
    for (int i = 0; i < n; ++i) {
        fout << skip;
        fout << vector << braces[0] << (i+istart) << braces[1] << " = " << names[i] << term << endl;
    }
}


void PrintNameList(ofstream &fout, lst names)
{
    int n;

    n = names.nops();
    for (int i = 0; i < n; ++i) {
        if (i > 0) {
            fout << ",";
        }
        fout << names[i];
    }
}


void PrintPi(ofstream &fout)
{
    fout << "3.14159265358979323846264338327950288";
}

//
// Print a multiline comment.  The argument comment can contain \n characters.
//
//
void PrintMultilineComment(ofstream &fout, const string &comment,
        const string &pre, const string &cmark)
{
    size_t n = 0;
    size_t s = 0;
    while (n != string::npos) {
        n = comment.find('\n',s);        
        fout << pre << cmark << comment.substr(s, n-s+1);
        s = n + 1;
    }
    fout << endl;
}

//
//  Some functions specific to FORTRAN output.
//

//
// This function will be used to override ginac's default method for printing
// "power" objects in the csrc output format.  This function prints it using
// the Fortran ** notation.
// 
void print_power_as_fortran(const power& p, const print_csrc& c, unsigned level)
{
    unsigned power_prec = p.precedence();
    if (level >= power_prec) {
        c.s << "(";
    }
    p.op(0).print(c,power_prec);
    c.s << "**";
    p.op(1).print(c,power_prec);
    if (level >= power_prec) {
        c.s << ")";
    }
}


//
// This is a hack to convert 'e' to 'D' in the representation of floating
// point numbers in the Fortran string. (A regex library could have been
// used, but that would make one more dependency for VFGEN.)
// Conversion examples:
//     1.0          ->  1.0D0
//     1.23123e-01  -> 1.23123D-01
// Eventually, it would be better to have a full-fledged Fortran output
// mode in GiNaC.
//
string fix_exp_notation(string &s)
{
    const string digits = "0123456789";
    size_t pos = s.find(".");
    if (pos == string::npos) {
        return s;
    }
    string newstr = s.substr(0, pos+1);
    while (pos != string::npos) {
        pos = pos + 1;
        size_t nondigitpos = s.find_first_not_of(digits,pos);
        if (nondigitpos == string::npos) {
            newstr = newstr + s.substr(pos,string::npos) + "D0";
            return newstr;
        }
        if (s[nondigitpos] == 'e') {
            newstr = newstr + s.substr(pos,nondigitpos-pos) + "D";
            pos = s.find(".",nondigitpos+1);
            newstr = newstr + s.substr(nondigitpos+1,pos-nondigitpos);
        }
        else {
            newstr = newstr + s.substr(pos,nondigitpos-pos) + "D0";
            pos = s.find(".",nondigitpos);
            newstr = newstr + s.substr(nondigitpos,pos-nondigitpos+1);
        }
    }
    return newstr;
}


void F77Write(ofstream &fout, string s)
{
    /*
    string newstr = fix_exp_notation(s);
    if (newstr != s)
        {
        cerr << "Before: \"" << s << "\"\n";
        cerr << "After:  \"" << newstr << "\"\n";
        s = newstr;
        }
    */
    s = fix_exp_notation(s);
    const int CharsPerLine = 66;
    int len = s.length();
    if (len < CharsPerLine) {
        fout << "      " << s << endl;
    }
    else {
        fout << "      " << s.substr(0,CharsPerLine) << endl;
        int n = CharsPerLine;
        while (n < len) {
            fout << "     &" << s.substr(n,CharsPerLine) << endl;
            n = n + CharsPerLine;
        }
    }
}


void F77Declare(ofstream &fout, lst names)
{
    int n;
    ostringstream os;

    n = names.nops();
    if (n < 1) {
        return;
    }
    os << "double precision ";
    for (int i = 0; i < n; ++i) {
        if (i > 0) {
            os << ", ";
        }
        os << names[i];
    }
    F77Write(fout, os.str());
}


void F90Write(ofstream &fout, string s)
{
    const int CharsPerLine = 130;
    int len = s.length();
    if (len < CharsPerLine) {
        fout << s << endl;
    }
    else {
        fout << s.substr(0,CharsPerLine) << '&' << endl;
        int n = CharsPerLine;
        while (n < len) {
            fout << "     &" << s.substr(n,CharsPerLine) << endl;
            n = n + CharsPerLine;
        }
    }
}
